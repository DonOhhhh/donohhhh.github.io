---
categories: [SWACADEMY]
---

# OS03

## Process Synchronization

---

### 등장 배경

- 공유된 데이터에 동시에 접근하는 것은 데이터 불일치를 초래할 수 있다.

### Critical Section Problem

- 각각의 프로세스는 Critical Section(임계 영역)을 가진다.
- 하나의 프로세스가 임계영역 안에 있을 때 다른 프로세스들은 해당 영역에 진입할 수 없다.
- 모든 프로세스는 entry section에 있는 critical section에 진입하기 위해선 허가를 받아야 한다.

### Critical Section Problem 해결책

#### Mutual Exclusion

- 만약 어떤 프로세스가 임계영역에서 실행된다면 다른 프로세스들은 그들 내부의 임계 영역에서 실행될 수 없다.

#### Progress

- 만약 어떠한 프로세스도 임계 영역에서 실행되고 있지 않고 임계 영역에 진입하길 원하는 프로세스가 존재할 때 크리티컬에 진입할 수 있는 프로세스를 선택하는 과정은 무한정 연기될 수 없다.

#### Bounded Waiting

- 프로세스들이 진입 요청을 생성하고 해당 요청이 승인되기 전에 프로세스들이 임계 영역에 진입할 수 있는 횟수의 제한이 반드시 존재해야 한다.

### OS에서의 Critical-Section 처리

#### Preemptive

- kernel mode일 때 프로세스가 선점하도록 허락한다.

#### Non-Preemptive

- kernel mode가 끝날 때까지 동작한다.

### Peterson's Solution

- turn과 flag 둘 중 하나가 만족하는 프로세스만 임계 영역에 진입하도록 허락해주는 방법

### Mutex Locks

- `acquire()`을 이용하여 임계영역에 진입하고 `release()`를 이용하여 임계 영역을 해제한다.
- `acquire()`과 `release()`는 한 개의 명령으로 수행된다.
- 이 해결 방법은 busy waiting을 얻는다.

### Semaphore

- Mutex locks보다 더욱 정교한 방식으로 프로세스의 활동을 동기화한다.
- 2개의 단일 명령(`wait()`, `signal()`)에 의해서만 접근될 수 있다.
- 같은 세마포어에 있는 두 프로세스 `wait()`와 `signal()`을 동시에 실행할 수 없다.
- `wait()`와 `signal()`가 동시에 수행될 수 없기 때문에 critical section problem에서 busy waiting문제가 발생한다.
- busy waiting없이 semaphore를 구현하기 위해서는 큐가 필요하다.
- 해당 큐에서 2가지 연산을 수행한다.
  - block - 연산을 수행하는 프로세스를 waiting queue의 적절한 위치에 위치시킨다.
  - wakeup - waiting queue에서 하나의 프로세스를 제거한 후 해당 프로세스를 ready queue에 위치시킨다.

#### Counting semaphore

- 정수값이 무한정 늘어날 수 있다.

#### Binary semaphore

- 정수값은 0과 1사이의 값만 될 수 있다.

### Deadlock

- 2개 이상의 프로세스들이 하나의 프로세스에서만 실행되는 하나의 이벤트를 실행하길 무한정 기다리는 현상이다.

### Starvation

- 세마포어 큐에서 절대 제거될 수 없는 현상이다.

### Priority Inversion

- 상위 우선순위의 프로세스들에게 필요한 lock을 우선순위가 낮은 프로세스들이 가지고 있을 때 발생하는 스케쥴링 문제

### 전통적인 동기화의 문제

#### Bounded-Buffer Problem
#### Readers-Writers Problem
- 변종1 : writer가 공유된 자원을 쓸 수 있는 허가권이 없는한 모든 readers가 계속해서 대기상태에 존재하는 것
- 변종2 : writer가 준비된다면 그 즉시 write를 한다.
#### Dining Philosophers Problem

### 함수형 프로그래밍

- 함수형 프로그래밍에서는 절차형 프로그래밍과는 다르게 한 번 변수에 초기화된 값은 절대로 변경될 수 없다.
- erlang과 Scala에서 데이터 경쟁을 처리하는 접근 방식에 대한 관심이 높아지고 있다.

## Main memory

- 메인 메모리와 레지스터가 CPU에서 직접적으로 접근할 수 있는 저장장치이다.
- 메인 메모리는 CPU registers와 메인 메모리 사이에서 stall Cache를 발생시키는 사이클을 가질 수 있다.
- 정확한 연산을 보장하기 위해서 메모리의 보호가 필요하다.

### Base and Limit Registers

- base와 limit registers 쌍은 논리적 주소 공간을 정의한다.
- CPU는 user mode에서 생성된 모든 메모리 접근이 해당 유저를 위한 base와 limit 사이에 있는지 확인한다.


