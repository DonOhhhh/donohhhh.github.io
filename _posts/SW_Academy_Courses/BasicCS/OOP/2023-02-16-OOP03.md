---
categories: [SWACADEMY]
---

# OOP03

## 상속과 접근 제어자

### 특별한 메소드 - 생성자

- 클래스를 객체화할 때 객체의 상태를 초기화하는 메소드
- 모든 클래스는 "반드시" 1개 이상의 생성자를 가짐
- 객체화 시에 "항상" 호출
- 메소드 이름은 클래스와 동일하며 반환 자료형이 없는 특징
- 클래스에 생성자가 없을 시, 컴파일러가 "기본" 생성자를 만듦.

### 생성자 여러개 만들기

- 2개 이상의 생성자를 가진 클래스 정의 기능
- 객체화 시, 원하는 생성자를 호출하여 원하는 형태의 객체 생성

#### 메소드 오버로딩

- 스크립트 언어를 static polymorphism이 없기 때문에 생성자를 지원하지 않는다.
- 메소드 호출 시 사용되는 인자의 개수, 자료형에 따라 호출되는 대상 함수가 결정
- 다음시간에 상세히 다룰 예정
- 하나의 생성자에서 다른 생성자 호출 가능(this...). 단, 생성자의 가장 첫 구분에서 수행해야 함.

### 변수의 초기화

- 모든 멤버 변수는 클래스의 생성자에게 초기화하는 것이 원칙
- 스태틱 변수는 별도의 스태틱 블록을 사용하거나 명시적 초기화를 수행
- 변수를 초기화하지 않는 경우, 자료형에 따른 Java 기본 값으로 자동 초기화 수행
- boolean : false, int : 0, float : 0.0f, double: 0.0, Object : null

### 상속이란?

- 기존의 클래스를 재사용하여 새로운 클래스를 파생해 내는 것
- 두 클래스가 부모-자식 관계를 이룸
  - 기반 클래스가 부모, 파생된 클래스가 자식
- 자식은 부모의 멤버 변수 및 메소드를 상속
  - 단, 생성자는 제외
- 자식은 상속받은 멤버 외에 자기 자신의 멤버를 가질 수 있음
  - 부모를 확장하여 특성 및 기능을 추가

### 클래스 사이의 관계 : has-a

- 포함(has-a) 관계란, 한 클래스의 멤버변수로 다른 클래스의 객체를 갖는 것
- 클래스 Circle이 클래스 Point를 포함(has-a)한다.
- 클래스를 조합하여 하나의 큰 클래스를 생성

### 클래스 사이의 관계 : is-a vs has-a

- 클래스 사이 관계를 정의할 때, 상속(is-a)과 포함(has-a) 사이의 고려가 필요
- is-a와 has-a로 문장을 만들어 어울리는 방향을 선택

### 접근 지정자(접근 제어자)

- public : 접근 제한 없음
- protected : 동일한 패키지 + 자식 클래스만 접근 가능
- default : 동일한 패키지 내의 클래스만 접근 가능
- private : 클래스 내부에서만 접근 가능

default를 제외한 다른 제어자 개념은 다른 언어에도 공통적으로 등장한다. 캡슐화를 수행하는데 있어 중요한 요소이다.


### 상속과 오버라이딩

- 오버라이딩(overriding)은 부모 클래스의 메소드를 자식 클래스에서 재정의하는 것
- 메소드를 자식 클래스에 맞도록 덮어씀.
- 메소드 이름, 매개변수, 리턴타입이 반드시 같아야 함.
- 접근 지정자가 같거나 넓어져야 함.

### 상속과 다형성

- 다형성이란 어떤 하나의 것이 여러 형태 또는 의미를 가질 수 있는 것이다.
- 상속을 통해 다형성을 지원한다.
- 상속을 통한 부모 자식 관계 = 분류와 세부 분류의 관계
- 자식의 객체는 부모의 분류에 속함.

### 동적 디스패치

- 동적 디스패치(dynamic dispatch)란 어떤 메소드를 부를지를 **실행 시점**에 결정하는 것
- 정적 디스패치(static dispatch)란 어떤 메소드를 부를지 **컴파일 시점**에 결정
- Java는 수신자 객체에 기반한 동적 디스패치를 진행
  - static 메소드와 private 메소드 호출은 정적 디스패치로 처리
  - static은 수신자 객체가 없고, private 메소드는 항상 하나로 특정되므로
- 다형성 지원의 중요한 요소 중 하나이다.
- **디스패치는 메소드 호출에 관련된 것이라서 멤버필드에는 동적 디스패치가 적용되지 않는다. 따라서 멤버 필드는 변수 타입에 따라 접근!** 