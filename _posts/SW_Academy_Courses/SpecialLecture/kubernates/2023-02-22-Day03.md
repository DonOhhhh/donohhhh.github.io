---
categories: [SWACADEMY]
---

# Day03

## ELK를 활용한 모니터링 시스템 구축 실습

### ELK Stack이란?

"ELK"는 Elasticsearch, Logstash 및 Kibana라는 3가지 오픈 소스의 앞글자에서 따온 용어

#### Elasticsearch

**Elasticsearch**는 자바 Apache Lucene 기반의 검색 및 분석 엔진이다. 문서를 수집하고 수집된 문서를 검색이 쉽도록 색인하고, 저장된 색인으로부터 질의에 해당하는 문서를 검색하여 결과로 제공한다. 색인된 데이터 기반의 각종 집계도 지원한다.

#### Logstash

**Logstash**는 여러 소스에서 동시에 데이터를 수집하여 변환한 후 Elasticsearch 같은 "stash"로 전송하는 서버 사이드 렌더링 처리 파이프라인이다. 
서버 데이터를 수집, 변환, 전송하는 데이터 처리 파이프라인으로 Jruby(JVM 기반 ruby)로 개발되었다.

Logstash의 데이터 처리 과정은 input, filter, output의 세 단계로 구성된다.
- input : 데이터가 유입되는 소스
- filter : 유입된 데이터를 어떻게 변형할 것인지의 과정
- output : 데이터를 전송할 목적지

#### Kibana

**Kibana**는 Elasticsearch에 있는 데이터를 시각화할 수 있도록 하는 웹 브라우저 기반의 시각화 플랫폼이다.
Elasticsearch에 있는 인덱스의 패턴을 찾아서, 데이터를 확인(Discover)하거나, 시각화할 수 있도록 한다.

## docker-compose로 EFK 생성 실습

### EFK Stack이란?

"EFK"는 Elasticsearch, Fluentd, Kibana라는 3가지 오픈 소스의 앞글자에서 따온 용어

### Fluentd

Logstash와 비슷하지만 좀 더 많은 플러그인들을 가지고 있음.

## Kubernetes 배포 및 운영 실습

### Kubernetes가 필요한 이유

대부분의 애플리케이션은 하나의 프로세스 및 몇 개의 서버에 분산된 프로세스로 실행되는 거대한 monolithic application이다.
monolithic이란 한 덩어리로 뭉쳐진 단일 서비스 개발 방식, 하나의 프로젝트로 구성되어 있으며 단일 패키지로 배포하는 방식이다.

monolithic application의 특징

- 릴리즈 주기가 느리고 업데이트가 자주 일어나지 않는게 특징이다.
- 개발자는 전체 릴리즈 주기가 끝날 때마다 전체 시스템을 패키징하고 운영팀은 이를 배포하고 모니터링한다.
- 운영팀은 하드웨어 장애가 발생하면 이를 사용 가능한 서버로 직접 마이그레이션을 한다.

거대해진 monolithic application은 microservice application으로 세분화할 수 있다.
microservice란 하나의 큰 어플리케이션을 여러 개의 작은 어플리케이션으로 쪼개어서 배포하는 방식이다.

microservice application의 특징

- 서로 분리되어 있기 때문에 개별적으로 개발, 배포, 업데이트, 확장 가능
- 배포 가능한 구성요소가 많아지고 데이터센터 규모가 커지면서 전체 시스템을 구성, 관리, 유지하기가 쉽지 않다.
- 리소스 활용을 높이고 하드웨어 비용을 낮추고 각 구성요소를 배치할 위치를 파악하기에 너무 어렵다.
- 수동으로 구현이 불가능하다.
- 구성요소를 자동으로 스케쥴링하고 구성, 관리, 장애처리를 포함하는 자동화가 필요하다.

위와 같은 이유로 쿠버네티스가 등장하였다.

### 마이크로서비스 배포의 단점

- 시스템이 소수의 구성요소로 되어 있으면 그 구성요소를 쉽게 관리할 수 있다.
- 각 구성요소를 어디에 배포할지를 결정하는 일은 선택사항이 많지 않기 때문에 간단하다.
- 하지만 구성 요소가 많아지면 배포 조합의 수 뿐만 아니라 구성 요소간의 상호 종속성 수가 훨씬 많으지므로 배포 관련 결정이 어렵다.
- 마이크로서비스는 여러 개가 함께 작업을 수행하므로 서로를 찾아 통신해야 한다.
- 배포할 때 전체가 하나의 시스템처럼 동작할 수 있도록 누군가 또는 무언가를 제대로 구성해야 한다.
- 마이크로서비스 수가 증가함에 따라 서버 장애 상황에서 시슨템 운영 팀이 해야할 일을 생각해보면 이 구성 작업은 오류가 날 가능성이 높아진다.
- 마이크로서비스는 여러 프로세스와 시스템에 분산돼 있기 때문에 실행 호출을 디버깅하고 추적하기가 어렵다.

### Kubernetes란?

구글이 개발한 애플리케이션 개발자와 시스템 관리자가 수 천개의 어플리케이션과 서비스를 관리하도록 도움을 주는 오픈소스 프로그램이다.

### 컨테이너를 쓰는 이유

- 경량 : 컨테이너 시스템 OS 커널을 공유함으로써 애플리케이션마다 전체 OS 인스턴스가 필요하지 않으며, 리소스에서 컨테이너 파일의 소형화와 간편함을 제공한다.
- 이식성 및 플랫폼 독립성 : 컨테이너가 모든 종속 항목들을 자신과 함께 전달하므로 일단 소프트웨어를 한 번만 작성하면 랩탑, 클라우드, 온프레미스 컴퓨팅 환경에서 이를 재구성하지 않고도 바로 실행이 가능하다.
- 최신형 개발 및 아키텍쳐 지원 : 플랫폼 간의 배치 이식성/일관성 및 소형 크기의 조합 덕분에 컨테이너는 최신형 개발에 매우 이상적이다.
- 활용도 향상 : 이전의 VM처럼 컨테이너를 사용하여 개발자와 운영자는 물리적 시스템의 CPU 및 메모리 활용도를 향상시킬 수 있다.

### Kubernetes의 컨테이너 오케스트레이션

- 프로비저닝
- 중복성
- 상태 모니터링
- 리소스 할당
- 스케일링 및 로드 밸런싱
- 물리적 호스트 간의 이동

### Kubernetes의 아키텍쳐

- 마스터 노드(Control Plane) : 전체 쿠버네티스 시스템을 제어하고 관리하는 쿠버네티스 컨트롤 플레인을 실행
  - API Server : 사용자, 컨트롤 플레인 구성 요소와 통신한다.
  - Control Manager : 구성 요소 복제본, 워커 노드 추적, 노드 장애 처리등과 같은 클러스터 단의 기능을 수행한다. 
  - Scheduler : 애플리케이션의 배포를 담당한다.
  - Etcd : 클러스터 구성을 지속적으로 저장하는 신뢰할 수 있는 분산 데이터 저장소이다.
- 워커 노드(Node) : 실제 배포되는 컨테이너 애플리케이션을 실행
  - Docker runtime : 컨테이너를 실행한다.
  - Kubelet : API 서버와 통신하고 노드의 컨테이너를 관리한다.
  - Kube-Proxy : 애플리케이션 구성 요소간의 네트워크 트래픽을 로드밸런싱한다.

### Kubernetes 용어

- 마스터 : 쿠버네티스 노드를 제어하는 머신, 여기에서 모든 태스크 할당이 시작
- 노드 : 할당된 태스크를 요청대로 수행하는 시스템, 쿠버네티스 마스터가 이러한 노드를 제어
- 파드 : 단일 노드에 배포된 하나 이상의 컨테이너 그룹이다. 포드에 있는 모든 컨테이너는 IP 주소, IPC, 호스트 이름, 기타 리소스를 공유하며 포드는 기본 컨테이너에서 네트워크와 스토리지를 추상화한다. 이렇게 하면 클러스터에서 컨테이너를 더 쉽게 이동이 가능하다.
- 복제 컨트롤러 : 이 컨트롤러는 클러스터에서 실행되어야 하는 동일한 포드 사본의 개수를 제어
- 서비스 : 포드에서 작업 정의를 분리한다. 쿠버네티스 서비스 프록시는 클러스터에서 다른 위치로 이동한 경우든 교체된 경우든 서비스 요청을 적절한 포드로 자동 수신한다.
- Kubelet : 이 서비스는 노드에서 실행되며 컨테이너 매니페스트를 읽고, 정의된 컨테이너가 시작되어 실행 중인지를 확인한다.
- Kubectl : 쿠버네티스의 명령줄 설정 툴

### Kubernetes 자격증

- 쿠버네티스 및 클라우드 네이티브 전문가(Kubernetes and Cloud Native Associate, KCNA)
- 공인 클라우드 애플리케이션 개발자(Certified Kubernetes Application Developer, CKAD)
- 공인 쿠버네티스 관리자(Certified Kubernetes Administrator, CKA)
- 공인 쿠버네티스 보안 전문가(Certified Kubernetes Security Specialist, CKS)

### 쿠버네티스 파드

쿠버네티스는 개별 컨테이너들을 직접 다루지 않는다. 함께 배치된 다수의 컨테이너라는 개념을 사용한다.
이 컨테이너 그룹을 pod(파드)라고 한다.
각 파드는 자체 ip, 호스트 이름, 프로세스 등이 있는 논리적으로 분리된 머신이다. 
애플리케이션은 단일 컨테이너로 실행되는 단일 프로세스일 수도 있고, 개별 컨테이너에서 실행된 주 어플리케이션 프로세스와 부가적으로 도와주는 프로세스로 이루어질 수 있다.








